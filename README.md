# Лабораторная работа №3

## Тема: Алгоритмический мини-пакет (структуры данных и сортировки)

В лабораторной работе реализован простой CLI интерфейс,
для его запуска необходимо запустить команду:

```shell

python -m src.main
```

### Функционал, с которым взаимодействует пользователь

1. Меню алгоритмов (factorial / fibo)
2. Меню сортировок
3. Меню стека

##### Выход из CLI в главном меню:

``` 
0
```

### Структура проекта

 <pre>
c1-s1-algorithmic-mini-batch/
├── src/                                # Исходный код
│   ├── algorithms/                     # Алгоритмы (факториал, фибоначчи)
│   ├── benchmarks/                     # Бенчмарки сортировок
│   ├── cli/                            # CLI-меню программы
│   ├── exceptions/                     # Исключения
│   ├── sorting/                        # Алгоритмы сортировки
│   ├── structures/                     # Структуры данных
│
├── tests/                              # тесты
│   ├── test_cases/                     # Генераторы массивов
│
├── .gitignore
├── .pre-commit-config.yaml
├── pyproject.toml
├── README.md
├── requirements.txt
└── uv.lock
</pre>

### Отчёт с бенчмарками:

Для сравнения производительности были замерены время работы шести сортировок:

- `bubble` — сортировка пузырьком
- `heap` — пирамидальная сортировка (heap sort)
- `quick` — быстрая сортировка
- `counting` — сортировка подсчётом
- `radix` — поразрядная сортировка
- `bucket` — блочная (карманная) сортировка

Тестовые массивы:

- `random_N` — случайные целые числа
- `nearly_N` — почти отсортированные массивы с небольшим числом перестановок
- `dups_N` — массивы с большим количеством повторяющихся значений
- `reverse_N` — массивы в обратном порядке

```
=== random_100 ===
bucket    :0.000135 сек
radix     :0.000153 сек
quick     :0.000256 сек
heap      :0.000299 сек
bubble    :0.001083 сек
counting  :0.001164 сек

=== nearly_100 ===
counting  :0.000036 сек
bucket    :0.000063 сек
radix     :0.000073 сек
quick     :0.000190 сек
heap      :0.000288 сек
bubble    :0.000624 сек

=== duplicates_100 ===
counting  :0.000039 сек
quick     :0.000071 сек
radix     :0.000077 сек
bucket    :0.000097 сек
heap      :0.000243 сек
bubble    :0.000826 сек

=== reverse_100 ===
counting  :0.000039 сек
bucket    :0.000062 сек
radix     :0.000084 сек
quick     :0.000164 сек
heap      :0.000253 сек
bubble    :0.001206 сек

=== random_1000 ===
bucket    :0.001324 сек
counting  :0.001716 сек
radix     :0.002195 сек
quick     :0.003743 сек
heap      :0.004373 сек
bubble    :0.113993 сек

=== nearly_1000 ===
counting  :0.000476 сек
bucket    :0.000749 сек
radix     :0.001265 сек
quick     :0.002887 сек
heap      :0.004650 сек
bubble    :0.081508 сек

=== duplicates_1000 ===
counting  :0.000418 сек
quick     :0.000617 сек
bucket    :0.000902 сек
radix     :0.001236 сек
heap      :0.003816 сек
bubble    :0.097913 сек

=== reverse_1000 ===
counting  :0.000401 сек
bucket    :0.000794 сек
radix     :0.001232 сек
quick     :0.002448 сек
heap      :0.004165 сек
bubble    :0.129692 сек

=== random_5000 ===
counting  :0.002986 сек
bucket    :0.006297 сек
radix     :0.010242 сек
quick     :0.021404 сек
heap      :0.028731 сек
bubble    :2.726919 сек

=== nearly_5000 ===
counting  :0.002171 сек
bucket    :0.003746 сек
radix     :0.008117 сек
quick     :0.016894 сек
heap      :0.029109 сек
bubble    :2.157720 сек

=== duplicates_5000 ===
counting  :0.002062 сек
quick     :0.003194 сек
bucket    :0.004208 сек
radix     :0.007610 сек
heap      :0.022720 сек
bubble    :2.467872 сек

=== reverse_5000 ===
counting  :0.002097 сек
bucket    :0.004239 сек
radix     :0.008182 сек
quick     :0.014906 сек
heap      :0.025753 сек
bubble    :3.330875 сек
```

### Выводы

- Bubble - самый медленный, на больших массивах время растёт очень сильно.

- Counting - почти всегда самый быстрый, особенно на массивах с дубликатами.

- Radix - быстрый и стабильный, чуть медленнее counting, но менее требователен к диапазону.

- Bucket - хорош на случайных и почти отсортированных данных, но теряет преимущество при большом количестве повторов.

- Quick - быстрый универсальная сортировка. На случайных данных quick sort очень
  быстрый. На почти отсортированных, обратных массивах не самый эффективный.

- Heap - немного медленнее quick, но всегда стабилен и предсказуем.
